# -*- coding: utf-8 -*-
"""DOScalculate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AKH3vSzOfnm0Aiz8IKB15LP4yJ1q_WYU

.datファイルをドラック＆ドロップで読み込んでください
"""

##ファイル名を入力！！！拡張子はつけない
##Enter the File Name "WITHOUT" Extension 
FileName = "A-TT-250-256_eigs_TE"

##バンド図と並べたい場合は0。それ以外の場合は欲しいエネルギーよりも余分に計算し、欲しいエネルギーで切るのが良い
##0 if you want to line up next to the band diagram;
## Otherwise, calculate extra energy than you want and cut at the energy you want.

CHART_MAX = 1.1

from IPython.utils import path
import openpyxl ##Excelを読み書きするため
import tqdm ##プログレスバーを表示するため
from openpyxl.chart import( ##Excelにグラフを描画するため
    ScatterChart,
    BarChart,
    Reference,
    Series,
)
import math

IntegralInterval = 250 ##積分間隔の定義 Definition of Integral Interval
"""
   最適な間隔はまだわからないけど1000以上に分割するのはやり過ぎっぽい
   計算しているバンドのエネルギーの最大値 or
   計算ポイントの数といい感じの関数で表せたらいいかも
   I'm still not sure what the optimal interval is, but splitting it into 1000 or more seems like overkill.
   If it could be expressed as a function of "the maximum energy of the band being calculated" or "the number of calculation points".
"""

inputData = open(FileName + '.dat', 'r') ##datファイルを読み取りモードで開く Open the .dat File with reading Mode.
StateValue = []

for rows in inputData: 
  if rows[0] == '!': ##1行目を無視 Ignore the first row.
    continue

  row = rows.rstrip(('\n')).split('   ') ##行末の改行を削除し、'   'でデータを区切る Remove newline characters at the end of lines and separate data with '   '.
  for i in range(1, len(row)):
    try:
      StateValue.append(float(row[i])) ##配列にデータを格納 Stores data in an array
    except (IndentationError, ValueError): ##エラーの際に処理を飛ばす Skip processing in case of error
      pass
    """
    FDTDで計算を行った場合、数値が代入されておらず「.」だけの値がが含まれている場合がある
    その際にfloatへの変換ができない場合処理を飛ばす
    When a calculation is performed in FDTD, there are cases where there are no numerical values assigned and only "." is included in the calculation.
    In that case, if the value cannot be converted to a float, the process is skipped.
    """

inputData.close() ##開いたdatファイルを閉じる Close the .dat file opened
StateMax = max(StateValue) ##最もエネルギーの高かった点を代入 Assign the point with the highest energy.
ChartMax = 0 ##グラフの最大値を決める Determine the maximum value of the graph

##print(StateMax)

if StateMax >= 1: 

   ##グラフの最大値を指定していない場合、BandSOLVEのバンド図と揃えるため、1以上では整数で切り上げる
   ##If the maximum value of the graph is not specified, it is rounded up by an integer if it is greater than or equal to 1 to align with the BandSOLVE band diagram.

  ChartMax = math.ceil(StateMax) ##小数第1位で切り上げ Roll up at first decimal place
else:
  ChartMax = (math.ceil(StateMax*10))/10 ##小数第2位で切り上げ Roll up at second decimal place

if CHART_MAX != 0:
  ChartMax = CHART_MAX ##グラフの最大値が指定されている場合は代入
else: 
  path ##指定されていなければ何もしない

##print(ChartMax)

wb = openpyxl.Workbook() ##新しいエクセルファイルを開く Open the New EXCEL File
sheet = wb.active

CalRange = len(StateValue) ##配列の長さを計算量として定義する↓↓ Define array length as a computational quantity↓↓
Normalization = 1/CalRange ##正規化するために全体の状態数の総和で1を割ったものを用意 Divide 1 by the sum of the total number of states to normalize

for i in tqdm.tqdm(range(IntegralInterval+1)): ##プログレスバーを表示する
  NumberOfState = 0 ##状態数の初期化 Initialize the number of states
  """ 
  下から数え上げるよりも上のほうが状態数が多いので計算量が減る
  Since the higher the energy, the higher the number of states tends to be, counting from the top rather than from the bottom is less computationally demanding.
  """
  BottomOfRange = (ChartMax/IntegralInterval)*(IntegralInterval-i) ##計算範囲の下限 Lower limit of calculation range
  TopOfRange = (ChartMax/IntegralInterval)*(IntegralInterval+1-i) ##計算範囲の上限 Upper limit of calculation range
  sheet.cell(row = IntegralInterval+2-i, column = 1).value = BottomOfRange

  ##CalRange = len(StateValue) ##↑↑配列数は変わらないのでforに入る前に1回の計算で良い
  ##print("CalRange=")
  ##print(CalRange)
  """
  改良前・毎回全要素を計算するため計算時間が長い
  for j in range(len(StateValue)):
    if float(StateValue[j]) >= BottomOfRange and StateValue[j] < TopOfRange:
      NumberOfState += 1
  
  ↓↓改良後↓↓
  """
  j = 0
  ##while j < len(StateValue): ##毎回配列の長さを計算するのは抵効率 It is ineffective to calculate the length of the array each time.
  while j < CalRange:
    ##print(j)
    if float(StateValue[j]) >= BottomOfRange and StateValue[j] < TopOfRange:
      NumberOfState += Normalization ##範囲内の状態数を数え上げる Count all states in range
      ##print(j)
      del StateValue[j] ##計算量削減のためにカウントしたものは削除する The counted elements are deleted to reduce computational complexity.
      CalRange -=1 ##配列要素を削除した分計算範囲を減らす Reduce the calculation range by removing array elements
      ##j+=1
      ##配列の要素を削除して前につめたため、次のループでも同じ場所[j]を参照する Since the array elements were deleted and packed in front, the next loop will refer to the same location [j].
    else:
      j+=1
    
    ##j+=1

  sheet.cell(row = IntegralInterval+2-i, column = 2).value = NumberOfState ##Excelに計算した値を書き込む Write calculated values in Excel

from openpyxl import chart ##グラフの描画 Drawing a graph

Chart = BarChart() ##棒グラフを指定 Specify a bar graph
Chart.title = FileName + '-I' + str(IntegralInterval)
Chart.type = "bar" ##横向きの棒グラフ(縦向きはcal) Horizontal bar graph (vertical is cal)
Chart.style = 3 ##グラフのスタイルを指定 Specify graph style
Chart.height = 18 ##グラフの縦の大きさを指定 Specify the vertical size of the graph

xValue = Reference(sheet,min_col = 1, min_row = 2, max_row = IntegralInterval+2)
yValue = Reference(sheet,min_col = 2, min_row = 2, max_row = IntegralInterval+2)

Chart.add_data(yValue) ##y軸のデータ
Chart.set_categories(xValue) ##x軸のデータ
Chart.legend = None ##凡例を消す
Chart.x_axis.numFmt = "0.00" ##縦軸のラベルの書式指定 小数第2位まで表示
##縦向きの棒グラフが基本形で横向きはそれを反転してるからx_axisが縦軸なんだと思う。知らんけど。
##I think x_axis is the vertical axis because the vertical bar chart is the basic form and the horizontal one inverts it. Maybe...

##縦軸のラベルの間隔を設定する方法が見つからなかった。現状では手動でやるしかなさそう。。。
##I could not figure out how to set the labels to display on the vertical axis at what interval. Currently, the only way seems to be to set it yourself.

##棒の色を指定 Bar color setting
if FileName[-1] == "M":
  Chart.series[0].graphicalProperties.solidFill = "ff6699" ##TMなら赤色 If TM, then specify red
else:
  Chart.series[0].graphicalProperties.solidFill = "99ddee" ##TEなら青色 If TE, then specify blue

sheet.add_chart(Chart, "E2") ##E2にグラフを描画 Draw a graph at position E2

wb.save(FileName + '-M' + str(ChartMax) + '-I' + str(IntegralInterval) +  '-DOS.xlsx') ##エクセルファイルを保存 Save Excel file

wb.close() ##エクセルファイルを閉じる Close Excel file